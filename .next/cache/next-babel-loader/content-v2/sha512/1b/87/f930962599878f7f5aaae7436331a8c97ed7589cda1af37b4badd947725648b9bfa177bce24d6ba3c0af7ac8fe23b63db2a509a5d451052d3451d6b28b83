{"ast":null,"code":"const {\n  ObjectID\n} = require('mongodb');\n\nconst {\n  loginMongo\n} = require('../../models/mongo');\n\nconst jwt = require('jsonwebtoken');\n\nconst bcrypt = require('bcrypt');\n\nconst updateUser = async (_id, data = {}) => {\n  let {\n    db,\n    client\n  } = await loginMongo(process.env.MONGODB, 'users');\n  let rt = await db.update({\n    _id: new ObjectID(_id)\n  }, {\n    $set: data\n  });\n  client.close();\n  return rt ? true : false;\n};\n\nexport default async function handler(req, res) {\n  try {\n    const {\n      method,\n      cookies: {\n        tk\n      }\n    } = req;\n\n    if (tk) {\n      switch (method) {\n        case 'PUT':\n          try {\n            let {\n              id\n            } = jwt.verify(tk, process.env.JWTSECRET);\n\n            if (req.body.password) {\n              const hash = bcrypt.hashSync(req.body.password, 10);\n              req.body.password = hash;\n            }\n\n            console.log(\"++++\", id, req.body);\n            res.status(200).json(await updateUser(id, req.body));\n          } catch (e) {\n            res.status(200).json(false);\n          }\n\n          break;\n\n        default:\n          res.status(405).end(`Method ${method} Not Allowed`);\n      }\n    } else {\n      res.status(500).json({\n        statusCode: 500,\n        msg: \"Falha na autenticação\"\n      });\n    }\n  } catch (err) {\n    res.status(500).json({\n      statusCode: 500,\n      msg: err.message\n    });\n  }\n}","map":{"version":3,"sources":["/opt/js/storage_sys/pages/api/user.js"],"names":["ObjectID","require","loginMongo","jwt","bcrypt","updateUser","_id","data","db","client","process","env","MONGODB","rt","update","$set","close","handler","req","res","method","cookies","tk","id","verify","JWTSECRET","body","password","hash","hashSync","console","log","status","json","e","end","statusCode","msg","err","message"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAiBD,OAAO,CAAC,oBAAD,CAA9B;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMI,UAAU,GAAG,OAAMC,GAAN,EAAWC,IAAI,GAAC,EAAhB,KAAqB;AACrC,MAAI;AAACC,IAAAA,EAAD;AAAKC,IAAAA;AAAL,MAAe,MAAMP,UAAU,CAACQ,OAAO,CAACC,GAAR,CAAYC,OAAb,EAAsB,OAAtB,CAAnC;AACA,MAAIC,EAAE,GAAG,MAAML,EAAE,CAACM,MAAH,CAAU;AAACR,IAAAA,GAAG,EAAE,IAAIN,QAAJ,CAAaM,GAAb;AAAN,GAAV,EAAmC;AAACS,IAAAA,IAAI,EAAER;AAAP,GAAnC,CAAf;AACAE,EAAAA,MAAM,CAACO,KAAP;AACA,SAAOH,EAAE,GAAG,IAAH,GAAU,KAAnB;AACF,CALD;;AAOA,eAAe,eAAeI,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAgC;AAC5C,MAAG;AACA,UAAM;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,OAAO,EAAC;AAACC,QAAAA;AAAD;AAAlB,QAA2BJ,GAAjC;;AACA,QAAGI,EAAH,EAAM;AACH,cAAOF,MAAP;AACG,aAAK,KAAL;AACG,cAAG;AACA,gBAAI;AAAEG,cAAAA;AAAF,gBAASpB,GAAG,CAACqB,MAAJ,CAAWF,EAAX,EAAeZ,OAAO,CAACC,GAAR,CAAYc,SAA3B,CAAb;;AACA,gBAAGP,GAAG,CAACQ,IAAJ,CAASC,QAAZ,EAAqB;AAClB,oBAAMC,IAAI,GAAGxB,MAAM,CAACyB,QAAP,CAAgBX,GAAG,CAACQ,IAAJ,CAASC,QAAzB,EAAmC,EAAnC,CAAb;AACAT,cAAAA,GAAG,CAACQ,IAAJ,CAASC,QAAT,GAAoBC,IAApB;AACF;;AACDE,YAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAoBR,EAApB,EAAwBL,GAAG,CAACQ,IAA5B;AACAP,YAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,MAAM5B,UAAU,CAACkB,EAAD,EAAKL,GAAG,CAACQ,IAAT,CAArC;AACF,WARD,CAQC,OAAMQ,CAAN,EAAQ;AACNf,YAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,KAArB;AACF;;AACD;;AACH;AACGd,UAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBG,GAAhB,CAAqB,UAASf,MAAO,cAArC;AAfN;AAiBF,KAlBD,MAkBK;AACFD,MAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACG,QAAAA,UAAU,EAAE,GAAb;AAAkBC,QAAAA,GAAG,EAAE;AAAvB,OAArB;AACF;AACH,GAvBD,CAuBC,OAAMC,GAAN,EAAU;AACRnB,IAAAA,GAAG,CAACa,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACG,MAAAA,UAAU,EAAE,GAAb;AAAkBC,MAAAA,GAAG,EAAEC,GAAG,CAACC;AAA3B,KAArB;AACF;AACH","sourcesContent":["const { ObjectID } = require('mongodb');\nconst { loginMongo } = require('../../models/mongo');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\nconst updateUser = async(_id, data={})=>{\n   let {db, client} = await loginMongo(process.env.MONGODB, 'users')\n   let rt = await db.update({_id: new ObjectID(_id)},{$set: data})\n   client.close()\n   return rt ? true : false\n}\n\nexport default async function handler(req, res){\n   try{\n      const { method, cookies:{tk} } = req;\n      if(tk){\n         switch(method){\n            case 'PUT':\n               try{\n                  let { id } = jwt.verify(tk, process.env.JWTSECRET);\n                  if(req.body.password){\n                     const hash = bcrypt.hashSync(req.body.password, 10);\n                     req.body.password = hash\n                  }\n                  console.log(\"++++\", id, req.body)\n                  res.status(200).json(await updateUser(id, req.body))\n               }catch(e){\n                  res.status(200).json(false)\n               }\n               break;\n            default:\n               res.status(405).end(`Method ${method} Not Allowed`)\n         }\n      }else{\n         res.status(500).json({statusCode: 500, msg: \"Falha na autenticação\"})\n      }\n   }catch(err){\n      res.status(500).json({statusCode: 500, msg: err.message})\n   }\n}\n"]},"metadata":{},"sourceType":"module"}