{"ast":null,"code":"const {\n  loginMongo\n} = require('../../models/mongo');\n\nconst {\n  ObjectID\n} = require('mongodb');\n\nconst request = require('request');\n\nconst download = async (user_id, file_id, type) => {\n  let {\n    db,\n    client\n  } = await loginMongo(process.env.MONGODB, 'users');\n  let {\n    dropboxToken\n  } = await db.findOne({\n    _id: new ObjectID(user_id)\n  }, {\n    projection: {\n      _id: 0,\n      dropboxToken: 1\n    }\n  });\n  client.close();\n  console.log(dropboxToken);\n  return new Promise((s, r) => {\n    request.post({\n      url: `https://content.dropboxapi.com/2/files/download${type === 'folder' ? '_zip' : ''}`,\n      encoding: null,\n      headers: {\n        \"Authorization\": `Bearer ${dropboxToken}`,\n        \"Dropbox-API-Arg\": JSON.stringify({\n          path: file_id\n        })\n      }\n    }, (err, res, body) => {\n      if (err) return r(err);\n      s(body);\n    });\n  });\n};\n\nexport default async function handler(req, res) {\n  try {\n    const {\n      method\n    } = req;\n\n    switch (method) {\n      case 'POST':\n        try {\n          let {\n            user_id,\n            file_id,\n            type\n          } = req.body;\n          let buffer = await download(user_id, file_id, type);\n          res.status(200).send(buffer);\n        } catch (err) {\n          res.status(500).json({\n            statusCode: 500,\n            error: true,\n            msg: err\n          });\n        }\n\n        break;\n\n      default:\n        res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (err) {\n    res.status(500).json({\n      statusCode: 500,\n      error: true,\n      msg: err.message\n    });\n  }\n}","map":{"version":3,"sources":["/opt/js/storage_sys/pages/api/share-download.js"],"names":["loginMongo","require","ObjectID","request","download","user_id","file_id","type","db","client","process","env","MONGODB","dropboxToken","findOne","_id","projection","close","console","log","Promise","s","r","post","url","encoding","headers","JSON","stringify","path","err","res","body","handler","req","method","buffer","status","send","json","statusCode","error","msg","end","message"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAiBC,OAAO,CAAC,oBAAD,CAA9B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAeD,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAD,CAAvB;;AAEA,MAAMG,QAAQ,GAAG,OAAMC,OAAN,EAAeC,OAAf,EAAwBC,IAAxB,KAA+B;AAC7C,MAAI;AAACC,IAAAA,EAAD;AAAKC,IAAAA;AAAL,MAAe,MAAMT,UAAU,CAACU,OAAO,CAACC,GAAR,CAAYC,OAAb,EAAsB,OAAtB,CAAnC;AACA,MAAI;AAACC,IAAAA;AAAD,MAAiB,MAAML,EAAE,CAACM,OAAH,CAAW;AAACC,IAAAA,GAAG,EAAE,IAAIb,QAAJ,CAAaG,OAAb;AAAN,GAAX,EAAwC;AAAEW,IAAAA,UAAU,EAAC;AAACD,MAAAA,GAAG,EAAC,CAAL;AAAOF,MAAAA,YAAY,EAAC;AAApB;AAAb,GAAxC,CAA3B;AACAJ,EAAAA,MAAM,CAACQ,KAAP;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYN,YAAZ;AACA,SAAO,IAAIO,OAAJ,CAAY,CAACC,CAAD,EAAGC,CAAH,KAAO;AACvBnB,IAAAA,OAAO,CAACoB,IAAR,CAAa;AACVC,MAAAA,GAAG,EAAG,kDAAiDjB,IAAI,KAAG,QAAP,GAAkB,MAAlB,GAA2B,EAAG,EAD3E;AAEVkB,MAAAA,QAAQ,EAAE,IAFA;AAGVC,MAAAA,OAAO,EAAC;AACL,yBAAiB,UAASb,YAAa,EADlC;AAEL,2BAAmBc,IAAI,CAACC,SAAL,CAAe;AAACC,UAAAA,IAAI,EAAEvB;AAAP,SAAf;AAFd;AAHE,KAAb,EAOG,CAACwB,GAAD,EAAMC,GAAN,EAAWC,IAAX,KAAkB;AAClB,UAAGF,GAAH,EAAQ,OAAOR,CAAC,CAACQ,GAAD,CAAR;AACRT,MAAAA,CAAC,CAACW,IAAD,CAAD;AACF,KAVD;AAWF,GAZM,CAAP;AAaF,CAlBD;;AAoBA,eAAe,eAAeC,OAAf,CAAuBC,GAAvB,EAA4BH,GAA5B,EAAgC;AAC5C,MAAG;AACA,UAAM;AAAEI,MAAAA;AAAF,QAAaD,GAAnB;;AACA,YAAOC,MAAP;AACG,WAAK,MAAL;AACG,YAAG;AACA,cAAI;AAAE9B,YAAAA,OAAF;AAAWC,YAAAA,OAAX;AAAoBC,YAAAA;AAApB,cAA6B2B,GAAG,CAACF,IAArC;AACA,cAAII,MAAM,GAAG,MAAMhC,QAAQ,CAACC,OAAD,EAAUC,OAAV,EAAmBC,IAAnB,CAA3B;AACAwB,UAAAA,GAAG,CAACM,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBF,MAArB;AACF,SAJD,CAIC,OAAMN,GAAN,EAAU;AACRC,UAAAA,GAAG,CAACM,MAAJ,CAAW,GAAX,EAAgBE,IAAhB,CAAqB;AAACC,YAAAA,UAAU,EAAE,GAAb;AAAkBC,YAAAA,KAAK,EAAE,IAAzB;AAA+BC,YAAAA,GAAG,EAAEZ;AAApC,WAArB;AACF;;AACD;;AACH;AACGC,QAAAA,GAAG,CAACM,MAAJ,CAAW,GAAX,EAAgBM,GAAhB,CAAqB,UAASR,MAAO,cAArC;AAXN;AAaF,GAfD,CAeC,OAAML,GAAN,EAAU;AACRC,IAAAA,GAAG,CAACM,MAAJ,CAAW,GAAX,EAAgBE,IAAhB,CAAqB;AAACC,MAAAA,UAAU,EAAE,GAAb;AAAkBC,MAAAA,KAAK,EAAE,IAAzB;AAA+BC,MAAAA,GAAG,EAAEZ,GAAG,CAACc;AAAxC,KAArB;AACF;AACH","sourcesContent":["const { loginMongo } = require('../../models/mongo');\nconst { ObjectID } = require('mongodb');\nconst request = require('request');\n\nconst download = async(user_id, file_id, type)=>{\n   let {db, client} = await loginMongo(process.env.MONGODB, 'users')\n   let {dropboxToken} = await db.findOne({_id: new ObjectID(user_id)},{ projection:{_id:0,dropboxToken:1}})\n   client.close()\n   console.log(dropboxToken)\n   return new Promise((s,r)=>{\n      request.post({\n         url: `https://content.dropboxapi.com/2/files/download${type==='folder' ? '_zip' : ''}`,\n         encoding: null,\n         headers:{\n            \"Authorization\":`Bearer ${dropboxToken}`,\n            \"Dropbox-API-Arg\": JSON.stringify({path: file_id}),\n         },\n      }, (err, res, body)=>{\n         if(err) return r(err)\n         s(body) \n      })\n   })\n}\n\nexport default async function handler(req, res){\n   try{\n      const { method } = req;\n      switch(method){\n         case 'POST':\n            try{\n               let { user_id, file_id, type } = req.body\n               let buffer = await download(user_id, file_id, type)\n               res.status(200).send(buffer)\n            }catch(err){\n               res.status(500).json({statusCode: 500, error: true, msg: err})\n            }\n            break;\n         default:\n            res.status(405).end(`Method ${method} Not Allowed`)\n      }\n   }catch(err){\n      res.status(500).json({statusCode: 500, error: true, msg: err.message})\n   }\n}\n"]},"metadata":{},"sourceType":"module"}