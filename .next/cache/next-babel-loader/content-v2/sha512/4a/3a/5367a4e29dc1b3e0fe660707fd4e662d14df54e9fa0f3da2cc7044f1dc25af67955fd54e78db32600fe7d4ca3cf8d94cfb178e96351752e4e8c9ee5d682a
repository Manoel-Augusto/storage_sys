{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst jwt = require('jsonwebtoken');\n\nconst bcrypt = require('bcrypt');\n\nconst {\n  serialize\n} = require('cookie');\n\nconst {\n  loginMongo\n} = require('../../models/mongo');\n\nconst auth = async (email, password) => {\n  let {\n    db,\n    client\n  } = await loginMongo(process.env.MONGODB, 'users');\n  let emailExist = await db.findOne({\n    email\n  });\n  client.close();\n\n  if (emailExist) {\n    let {\n      _id: id,\n      password: password_crypt\n    } = emailExist,\n        rest = _objectWithoutProperties(emailExist, [\"_id\", \"password\"]);\n\n    if (bcrypt.compareSync(password, password_crypt)) {\n      let token = jwt.sign({\n        id\n      }, process.env.JWTSECRET, {\n        expiresIn: '1d'\n      });\n      return _objectSpread({\n        token\n      }, rest);\n    }\n  }\n\n  return false;\n};\n\nexport default async function handler(req, res) {\n  try {\n    const {\n      method\n    } = req;\n\n    if (method === 'POST') {\n      let {\n        email,\n        password\n      } = req.body;\n\n      let _await$auth = await auth(email, password),\n          {\n        token\n      } = _await$auth,\n          rest = _objectWithoutProperties(_await$auth, [\"token\"]);\n\n      if (token) {\n        res.setHeader('Set-Cookie', serialize('tk', token, {\n          httpOnly: true,\n          secure: false,\n          sameSite: 'strict',\n          maxAge: 3600,\n          path: '/'\n        }));\n        res.status(200).json(rest);\n      } //res.status(200).json(await auth(email,password))\n\n    } else {\n      res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (err) {\n    res.status(500).json({\n      statusCode: 500,\n      msg: err.message\n    });\n  }\n}","map":{"version":3,"sources":["/opt/js/storage_sys/pages/api/auth.js"],"names":["jwt","require","bcrypt","serialize","loginMongo","auth","email","password","db","client","process","env","MONGODB","emailExist","findOne","close","_id","id","password_crypt","rest","compareSync","token","sign","JWTSECRET","expiresIn","handler","req","res","method","body","setHeader","httpOnly","secure","sameSite","maxAge","path","status","json","end","err","statusCode","msg","message"],"mappings":";;;;;;;;;;AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAgBF,OAAO,CAAC,QAAD,CAA7B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAiBH,OAAO,CAAC,oBAAD,CAA9B;;AAEA,MAAMI,IAAI,GAAG,OAAMC,KAAN,EAAaC,QAAb,KAAwB;AAClC,MAAI;AAACC,IAAAA,EAAD;AAAKC,IAAAA;AAAL,MAAe,MAAML,UAAU,CAACM,OAAO,CAACC,GAAR,CAAYC,OAAb,EAAsB,OAAtB,CAAnC;AACA,MAAIC,UAAU,GAAG,MAAML,EAAE,CAACM,OAAH,CAAW;AAACR,IAAAA;AAAD,GAAX,CAAvB;AACAG,EAAAA,MAAM,CAACM,KAAP;;AACA,MAAGF,UAAH,EAAc;AACX,QAAI;AAAEG,MAAAA,GAAG,EAACC,EAAN;AAAUV,MAAAA,QAAQ,EAACW;AAAnB,QAA+CL,UAAnD;AAAA,QAA0CM,IAA1C,4BAAmDN,UAAnD;;AACA,QAAGX,MAAM,CAACkB,WAAP,CAAmBb,QAAnB,EAA6BW,cAA7B,CAAH,EAAgD;AAC7C,UAAIG,KAAK,GAAGrB,GAAG,CAACsB,IAAJ,CAAS;AAACL,QAAAA;AAAD,OAAT,EAAeP,OAAO,CAACC,GAAR,CAAYY,SAA3B,EAAsC;AAACC,QAAAA,SAAS,EAAE;AAAZ,OAAtC,CAAZ;AACA;AAAQH,QAAAA;AAAR,SAAkBF,IAAlB;AACF;AACH;;AACD,SAAO,KAAP;AACF,CAZD;;AAcA,eAAe,eAAeM,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAgC;AAC5C,MAAG;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAaF,GAAnB;;AACA,QAAGE,MAAM,KAAK,MAAd,EAAqB;AAClB,UAAI;AAAEtB,QAAAA,KAAF;AAASC,QAAAA;AAAT,UAAsBmB,GAAG,CAACG,IAA9B;;AACA,wBAAyB,MAAMxB,IAAI,CAACC,KAAD,EAAOC,QAAP,CAAnC;AAAA,UAAI;AAAEc,QAAAA;AAAF,OAAJ;AAAA,UAAgBF,IAAhB;;AACA,UAAGE,KAAH,EAAS;AACNM,QAAAA,GAAG,CAACG,SAAJ,CAAc,YAAd,EAA4B3B,SAAS,CAAC,IAAD,EAAOkB,KAAP,EAAc;AAChDU,UAAAA,QAAQ,EAAE,IADsC;AAEhDC,UAAAA,MAAM,OAF0C;AAGhDC,UAAAA,QAAQ,EAAE,QAHsC;AAIhDC,UAAAA,MAAM,EAAE,IAJwC;AAKhDC,UAAAA,IAAI,EAAE;AAL0C,SAAd,CAArC;AAOAR,QAAAA,GAAG,CAACS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBlB,IAArB;AACF,OAZiB,CAalB;;AACF,KAdD,MAcK;AACFQ,MAAAA,GAAG,CAACS,MAAJ,CAAW,GAAX,EAAgBE,GAAhB,CAAqB,UAASV,MAAO,cAArC;AACF;AACH,GAnBD,CAmBC,OAAMW,GAAN,EAAU;AACRZ,IAAAA,GAAG,CAACS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACG,MAAAA,UAAU,EAAE,GAAb;AAAkBC,MAAAA,GAAG,EAAEF,GAAG,CAACG;AAA3B,KAArB;AACF;AACH","sourcesContent":["const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst { serialize } = require('cookie');\nconst { loginMongo } = require('../../models/mongo');\n\nconst auth = async(email, password)=>{\n   let {db, client} = await loginMongo(process.env.MONGODB, 'users')\n   let emailExist = await db.findOne({email})\n   client.close()\n   if(emailExist){\n      let { _id:id, password:password_crypt, ...rest } = emailExist\n      if(bcrypt.compareSync(password, password_crypt)){\n         let token = jwt.sign({id}, process.env.JWTSECRET, {expiresIn: '1d'})\n         return {token, ...rest}\n      }\n   }\n   return false\n}\n\nexport default async function handler(req, res){\n   try{\n      const { method } = req;\n      if(method === 'POST'){\n         let { email, password } = req.body\n         let { token, ...rest } = await auth(email,password)\n         if(token){\n            res.setHeader('Set-Cookie', serialize('tk', token, {\n               httpOnly: true,\n               secure: process.env.NODE_ENV !== 'development',\n               sameSite: 'strict',\n               maxAge: 3600,\n               path: '/'\n            }));\n            res.status(200).json(rest)\n         }\n         //res.status(200).json(await auth(email,password))\n      }else{\n         res.status(405).end(`Method ${method} Not Allowed`)\n      }\n   }catch(err){\n      res.status(500).json({statusCode: 500, msg: err.message})\n   }\n}\n"]},"metadata":{},"sourceType":"module"}