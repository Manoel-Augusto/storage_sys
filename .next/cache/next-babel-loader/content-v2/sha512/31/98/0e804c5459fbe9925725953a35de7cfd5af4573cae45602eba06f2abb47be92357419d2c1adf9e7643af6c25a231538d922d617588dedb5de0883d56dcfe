{"ast":null,"code":"const jwt = require('jsonwebtoken');\n\nconst bcrypt = require('bcrypt');\n\nconst {\n  loginMongo\n} = require('../../models/mongo');\n\nconst auth = async (email, password) => {\n  let {\n    db,\n    client\n  } = await loginMongo(process.env.MONGODB, 'users');\n  let emailExist = await db.findOne({\n    email\n  }, {\n    projection: {\n      _id: 1,\n      name: 1,\n      password: 1\n    }\n  });\n  client.close();\n\n  if (emailExist) {\n    let {\n      _id: id,\n      name,\n      password: password_crypt\n    } = emailExist;\n\n    if (bcrypt.compareSync(password, password_crypt)) {\n      let token = jwt.sign({\n        id\n      }, process.env.JWTSECRET, {\n        expiresIn: '1d'\n      });\n      return {\n        name,\n        token\n      };\n    }\n  }\n\n  return false;\n};\n\nexport default async function handler(req, res) {\n  try {\n    const {\n      method\n    } = req;\n\n    if (method === 'POST') {\n      let {\n        email,\n        password\n      } = req.body;\n      res.status(200).json(await auth(email, password));\n    } else {\n      res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (err) {\n    res.status(500).json({\n      statusCode: 500,\n      msg: err.message\n    });\n  }\n}","map":{"version":3,"sources":["/opt/js/storage_sys/pages/api/auth.js"],"names":["jwt","require","bcrypt","loginMongo","auth","email","password","db","client","process","env","MONGODB","emailExist","findOne","projection","_id","name","close","id","password_crypt","compareSync","token","sign","JWTSECRET","expiresIn","handler","req","res","method","body","status","json","end","err","statusCode","msg","message"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAiBF,OAAO,CAAC,oBAAD,CAA9B;;AAEA,MAAMG,IAAI,GAAG,OAAMC,KAAN,EAAaC,QAAb,KAAwB;AAClC,MAAI;AAACC,IAAAA,EAAD;AAAKC,IAAAA;AAAL,MAAe,MAAML,UAAU,CAACM,OAAO,CAACC,GAAR,CAAYC,OAAb,EAAsB,OAAtB,CAAnC;AACA,MAAIC,UAAU,GAAG,MAAML,EAAE,CAACM,OAAH,CAAW;AAACR,IAAAA;AAAD,GAAX,EAAmB;AAAES,IAAAA,UAAU,EAAC;AAACC,MAAAA,GAAG,EAAC,CAAL;AAAOC,MAAAA,IAAI,EAAC,CAAZ;AAAcV,MAAAA,QAAQ,EAAC;AAAvB;AAAb,GAAnB,CAAvB;AACAE,EAAAA,MAAM,CAACS,KAAP;;AACA,MAAGL,UAAH,EAAc;AACX,QAAI;AAAEG,MAAAA,GAAG,EAACG,EAAN;AAAUF,MAAAA,IAAV;AAAgBV,MAAAA,QAAQ,EAACa;AAAzB,QAA4CP,UAAhD;;AACA,QAAGV,MAAM,CAACkB,WAAP,CAAmBd,QAAnB,EAA6Ba,cAA7B,CAAH,EAAgD;AAC7C,UAAIE,KAAK,GAAGrB,GAAG,CAACsB,IAAJ,CAAS;AAACJ,QAAAA;AAAD,OAAT,EAAeT,OAAO,CAACC,GAAR,CAAYa,SAA3B,EAAsC;AAACC,QAAAA,SAAS,EAAE;AAAZ,OAAtC,CAAZ;AACA,aAAO;AAACR,QAAAA,IAAD;AAAOK,QAAAA;AAAP,OAAP;AACF;AACH;;AACD,SAAO,KAAP;AACF,CAZD;;AAcA,eAAe,eAAeI,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAgC;AAC5C,MAAG;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAaF,GAAnB;;AACA,QAAGE,MAAM,KAAK,MAAd,EAAqB;AAClB,UAAI;AAAEvB,QAAAA,KAAF;AAASC,QAAAA;AAAT,UAAsBoB,GAAG,CAACG,IAA9B;AACAF,MAAAA,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,MAAM3B,IAAI,CAACC,KAAD,EAAOC,QAAP,CAA/B;AACF,KAHD,MAGK;AACFqB,MAAAA,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBE,GAAhB,CAAqB,UAASJ,MAAO,cAArC;AACF;AACH,GARD,CAQC,OAAMK,GAAN,EAAU;AACRN,IAAAA,GAAG,CAACG,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAACG,MAAAA,UAAU,EAAE,GAAb;AAAkBC,MAAAA,GAAG,EAAEF,GAAG,CAACG;AAA3B,KAArB;AACF;AACH","sourcesContent":["const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst { loginMongo } = require('../../models/mongo');\n\nconst auth = async(email, password)=>{\n   let {db, client} = await loginMongo(process.env.MONGODB, 'users')\n   let emailExist = await db.findOne({email},{ projection:{_id:1,name:1,password:1}})\n   client.close()\n   if(emailExist){\n      let { _id:id, name, password:password_crypt } = emailExist\n      if(bcrypt.compareSync(password, password_crypt)){\n         let token = jwt.sign({id}, process.env.JWTSECRET, {expiresIn: '1d'})\n         return {name, token}\n      }\n   }\n   return false\n}\n\nexport default async function handler(req, res){\n   try{\n      const { method } = req;\n      if(method === 'POST'){\n         let { email, password } = req.body\n         res.status(200).json(await auth(email,password))\n      }else{\n         res.status(405).end(`Method ${method} Not Allowed`)\n      }\n   }catch(err){\n      res.status(500).json({statusCode: 500, msg: err.message})\n   }\n}\n"]},"metadata":{},"sourceType":"module"}