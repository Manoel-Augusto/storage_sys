{"ast":null,"code":"const {\n  loginMongo\n} = require('../../models/mongo');\n\nconst {\n  ObjectID\n} = require('mongodb');\n\nconst jwt = require('jsonwebtoken');\n\nconst request = require('request');\n\nconst download = async (_id, path) => {\n  let {\n    db,\n    client\n  } = await loginMongo(process.env.MONGODB, 'users');\n  let {\n    dropboxToken\n  } = await db.findOne({\n    _id: new ObjectID(_id)\n  }, {\n    projection: {\n      _id: 0,\n      dropboxToken: 1\n    }\n  });\n  client.close();\n  return new Promise((s, r) => {\n    request.post({\n      url: \"https://content.dropboxapi.com/2/files/download\",\n      headers: {\n        \"Authorization\": `Bearer ${dropboxToken}`,\n        \"Dropbox-API-Arg\": JSON.stringify({\n          path\n        })\n      }\n    }, (err, res, body) => {\n      if (err) return r(err);\n      console.log(res.blob());\n      s(Buffer.from(body));\n    });\n  });\n};\n\nexport default async function handler(req, res) {\n  //try{\n  const {\n    method,\n    cookies: {\n      tk\n    }\n  } = req;\n\n  if (tk) {\n    switch (method) {\n      case 'POST':\n        //try{\n        let {\n          id\n        } = jwt.verify(tk, process.env.JWTSECRET);\n        let {\n          path\n        } = req.body;\n        let buffer = await download(id, path);\n        res.status(200).send(buffer);\n        /*}catch(err){\n              res.status(500).json({statusCode: 500, error: true, msg: err})\n           }*/\n\n        break;\n\n      default:\n        res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } else {\n    res.status(500).json({\n      statusCode: 500,\n      error: true,\n      msg: \"Falha na autenticação\"\n    });\n  }\n  /*}catch(err){\n     res.status(500).json({statusCode: 500, error: true, msg: err.message})\n  }*/\n\n}","map":{"version":3,"sources":["/opt/js/storage_sys/pages/api/download.js"],"names":["loginMongo","require","ObjectID","jwt","request","download","_id","path","db","client","process","env","MONGODB","dropboxToken","findOne","projection","close","Promise","s","r","post","url","headers","JSON","stringify","err","res","body","console","log","blob","Buffer","from","handler","req","method","cookies","tk","id","verify","JWTSECRET","buffer","status","send","end","json","statusCode","error","msg"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAiBC,OAAO,CAAC,oBAAD,CAA9B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAeD,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AAEA,MAAMI,QAAQ,GAAG,OAAMC,GAAN,EAAWC,IAAX,KAAkB;AAChC,MAAI;AAACC,IAAAA,EAAD;AAAKC,IAAAA;AAAL,MAAe,MAAMT,UAAU,CAACU,OAAO,CAACC,GAAR,CAAYC,OAAb,EAAsB,OAAtB,CAAnC;AACA,MAAI;AAACC,IAAAA;AAAD,MAAiB,MAAML,EAAE,CAACM,OAAH,CAAW;AAACR,IAAAA,GAAG,EAAE,IAAIJ,QAAJ,CAAaI,GAAb;AAAN,GAAX,EAAoC;AAAES,IAAAA,UAAU,EAAC;AAACT,MAAAA,GAAG,EAAC,CAAL;AAAOO,MAAAA,YAAY,EAAC;AAApB;AAAb,GAApC,CAA3B;AACAJ,EAAAA,MAAM,CAACO,KAAP;AACA,SAAO,IAAIC,OAAJ,CAAY,CAACC,CAAD,EAAGC,CAAH,KAAO;AACvBf,IAAAA,OAAO,CAACgB,IAAR,CAAa;AACVC,MAAAA,GAAG,EAAE,iDADK;AAEVC,MAAAA,OAAO,EAAC;AACL,yBAAiB,UAAST,YAAa,EADlC;AAEL,2BAAmBU,IAAI,CAACC,SAAL,CAAe;AAACjB,UAAAA;AAAD,SAAf;AAFd;AAFE,KAAb,EAMG,CAACkB,GAAD,EAAMC,GAAN,EAAWC,IAAX,KAAkB;AAClB,UAAGF,GAAH,EAAQ,OAAON,CAAC,CAACM,GAAD,CAAR;AACRG,MAAAA,OAAO,CAACC,GAAR,CAAYH,GAAG,CAACI,IAAJ,EAAZ;AACAZ,MAAAA,CAAC,CAACa,MAAM,CAACC,IAAP,CAAYL,IAAZ,CAAD,CAAD;AACF,KAVD;AAWF,GAZM,CAAP;AAaF,CAjBD;;AAmBA,eAAe,eAAeM,OAAf,CAAuBC,GAAvB,EAA4BR,GAA5B,EAAgC;AAC5C;AACA,QAAM;AAAES,IAAAA,MAAF;AAAUC,IAAAA,OAAO,EAAC;AAACC,MAAAA;AAAD;AAAlB,MAA2BH,GAAjC;;AACA,MAAGG,EAAH,EAAM;AACH,YAAOF,MAAP;AACG,WAAK,MAAL;AACG;AACA,YAAI;AAAEG,UAAAA;AAAF,YAASnC,GAAG,CAACoC,MAAJ,CAAWF,EAAX,EAAe3B,OAAO,CAACC,GAAR,CAAY6B,SAA3B,CAAb;AACA,YAAI;AAAEjC,UAAAA;AAAF,YAAW2B,GAAG,CAACP,IAAnB;AACA,YAAIc,MAAM,GAAG,MAAMpC,QAAQ,CAACiC,EAAD,EAAK/B,IAAL,CAA3B;AACAmB,QAAAA,GAAG,CAACgB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBF,MAArB;AACA;AACZ;AACA;;AACY;;AACH;AACGf,QAAAA,GAAG,CAACgB,MAAJ,CAAW,GAAX,EAAgBE,GAAhB,CAAqB,UAAST,MAAO,cAArC;AAZN;AAcF,GAfD,MAeK;AACFT,IAAAA,GAAG,CAACgB,MAAJ,CAAW,GAAX,EAAgBG,IAAhB,CAAqB;AAACC,MAAAA,UAAU,EAAE,GAAb;AAAkBC,MAAAA,KAAK,EAAE,IAAzB;AAA+BC,MAAAA,GAAG,EAAE;AAApC,KAArB;AACF;AACD;AACH;AACA;;AACC","sourcesContent":["const { loginMongo } = require('../../models/mongo');\nconst { ObjectID } = require('mongodb');\nconst jwt = require('jsonwebtoken');\nconst request = require('request');\n\nconst download = async(_id, path)=>{\n   let {db, client} = await loginMongo(process.env.MONGODB, 'users')\n   let {dropboxToken} = await db.findOne({_id: new ObjectID(_id)},{ projection:{_id:0,dropboxToken:1}})\n   client.close()\n   return new Promise((s,r)=>{\n      request.post({\n         url: \"https://content.dropboxapi.com/2/files/download\",\n         headers:{\n            \"Authorization\":`Bearer ${dropboxToken}`,\n            \"Dropbox-API-Arg\": JSON.stringify({path}),\n         },\n      }, (err, res, body)=>{\n         if(err) return r(err)\n         console.log(res.blob())\n         s(Buffer.from(body)) \n      })\n   })\n}\n\nexport default async function handler(req, res){\n   //try{\n   const { method, cookies:{tk} } = req;\n   if(tk){\n      switch(method){\n         case 'POST':\n            //try{\n            let { id } = jwt.verify(tk, process.env.JWTSECRET);\n            let { path } = req.body\n            let buffer = await download(id, path)\n            res.status(200).send(buffer)\n            /*}catch(err){\n                  res.status(500).json({statusCode: 500, error: true, msg: err})\n               }*/\n            break;\n         default:\n            res.status(405).end(`Method ${method} Not Allowed`)\n      }\n   }else{\n      res.status(500).json({statusCode: 500, error: true, msg: \"Falha na autenticação\"})\n   }\n   /*}catch(err){\n      res.status(500).json({statusCode: 500, error: true, msg: err.message})\n   }*/\n}\n"]},"metadata":{},"sourceType":"module"}